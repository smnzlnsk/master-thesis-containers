package main

import (
	"context"
	"fmt"
	"log"
	"math"
	"math/rand"
	"net/http"
	"os"
	"os/signal"
	"sync/atomic"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
	"go.opentelemetry.io/otel/metric"
	sdkmetric "go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// buildVersion will be set during build via -ldflags
var buildVersion = "0.0.0" // Default version if not set during build

var (
	serviceName    = "fps-monitoring-app"
	serviceVersion = buildVersion // Use the build version
	hostname       = getEnv("HOSTNAME", "fps-host")
	otlpEndpoint   = getEnv("OTEL_EXPORTER_OTLP_ENDPOINT", "localhost:4317") // Default OTLP HTTP endpoint
	// FPS configuration
	minFPS     = 30.0             // Minimum FPS in the sine wave
	maxFPS     = 120.0            // Maximum FPS in the sine wave
	sinePeriod = 15 * time.Second // Complete sine wave cycle takes 15 seconds
)

// Global variable to track current FPS - use atomic operations for thread safety
var inFPSValue uint64 = 0  // FPS in value stored as bits
var outFPSValue uint64 = 0 // FPS out value stored as bits

// Global metric instruments
var (
	fpsObservableGauge metric.Float64ObservableGauge
)

// calculateInFPS returns the current in FPS value
func calculateInFPS() float64 {
	bits := atomic.LoadUint64(&inFPSValue)
	return math.Float64frombits(bits)
}

// calculateOutFPS returns the current out FPS value
func calculateOutFPS() float64 {
	bits := atomic.LoadUint64(&outFPSValue)
	return math.Float64frombits(bits)
}

// storeInFPS stores a float64 value atomically for FPS in
func storeInFPS(val float64) {
	bits := math.Float64bits(val)
	atomic.StoreUint64(&inFPSValue, bits)
}

// storeOutFPS stores a float64 value atomically for FPS out
func storeOutFPS(val float64) {
	bits := math.Float64bits(val)
	atomic.StoreUint64(&outFPSValue, bits)
}

// getEnv retrieves an environment variable or returns a default value if not set
func getEnv(key, defaultValue string) string {
	value, exists := os.LookupEnv(key)
	if !exists {
		return defaultValue
	}
	return value
}

func initMetrics(ctx context.Context) (func(context.Context) error, error) {
	// Create resource with service information
	res, err := resource.New(ctx,
		resource.WithAttributes(
			semconv.ServiceName(serviceName),
			semconv.ServiceVersion(serviceVersion),
			semconv.HostName(hostname),
			attribute.String("container_id", hostname),
		),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create resource: %w", err)
	}

	// Create OTLP gRPC exporter
	exporter, err := otlpmetricgrpc.New(ctx,
		otlpmetricgrpc.WithEndpoint(otlpEndpoint),
		otlpmetricgrpc.WithInsecure(), // Use insecure connection for local development
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
	}

	// Create metric provider
	provider := sdkmetric.NewMeterProvider(
		sdkmetric.WithResource(res),
		sdkmetric.WithReader(sdkmetric.NewPeriodicReader(exporter,
			sdkmetric.WithInterval(1*time.Second), // Export metrics every 5 seconds
		)),
	)

	// Set global meter provider
	otel.SetMeterProvider(provider)

	// Create meter
	meter := provider.Meter(
		"fps-monitoring",
		metric.WithInstrumentationVersion(serviceVersion),
		metric.WithSchemaURL(semconv.SchemaURL),
	)

	// Create FPS observable gauge metric
	fpsObservableGauge, err = meter.Float64ObservableGauge(
		"service_fps",
		metric.WithDescription("The frames per second generated by the application"),
		metric.WithUnit("fps"),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create FPS observable gauge: %w", err)
	}

	// Register callback to provide current FPS values
	_, err = meter.RegisterCallback(
		func(ctx context.Context, observer metric.Observer) error {
			inFPS := calculateInFPS()
			outFPS := calculateOutFPS()

			observer.ObserveFloat64(fpsObservableGauge, inFPS, metric.WithAttributes(
				attribute.String("state", "in"),
			))
			observer.ObserveFloat64(fpsObservableGauge, outFPS, metric.WithAttributes(
				attribute.String("state", "out"),
			))
			return nil
		},
		fpsObservableGauge,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to register FPS callback: %w", err)
	}

	// Create hostname HTTP server for port 80
	hostnameHandler := http.NewServeMux()
	hostnameHandler.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path != "/" {
			w.WriteHeader(http.StatusNotFound)
			return
		}
		w.Header().Set("Content-Type", "text/plain")
		fmt.Fprintf(w, "%s\n", hostname)
	})

	// Create and start hostname HTTP server on port 80
	hostnameServer := &http.Server{
		Addr:    ":8090",
		Handler: hostnameHandler,
	}
	go func() {
		log.Printf("Starting hostname HTTP server on port 80")
		if err := hostnameServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Failed to serve hostname HTTP server on port 80: %v", err)
		}
	}()

	// Return a function that will shut down the services
	return func(ctx context.Context) error {
		// Shut down the hostname HTTP server
		if err := hostnameServer.Shutdown(ctx); err != nil {
			log.Printf("Warning: Failed to shutdown hostname HTTP server: %v", err)
		}

		// Shutdown the metric provider
		if err := provider.Shutdown(ctx); err != nil {
			log.Printf("Warning: Failed to shutdown metric provider: %v", err)
		}

		return nil
	}, nil
}

func simulateFPS(ctx context.Context) {
	// Set initial value
	initialFPS := (maxFPS + minFPS) / 2 // Start in the middle
	storeInFPS(initialFPS)
	storeOutFPS(initialFPS)

	// Calculate FPS range (amplitude of the sine wave)
	fpsAmplitude := (maxFPS - minFPS) / 2
	fpsMidpoint := (maxFPS + minFPS) / 2

	// Record the start time to calculate the sine wave position
	startTime := time.Now()

	// Main simulation loop
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			// Calculate elapsed time since start
			elapsed := time.Since(startTime)

			// Calculate the position in the sine wave (0 to 2Ï€)
			// A complete sine wave should take sinePeriod (15 seconds)
			position := 2 * math.Pi * (elapsed.Seconds() / sinePeriod.Seconds())

			// Calculate the sine value (-1 to 1)
			sineValue := math.Sin(position)

			// Convert sine value to FPS range
			baseFPS := fpsMidpoint + fpsAmplitude*sineValue

			// Add independent random variations
			// 5% variation for inFPS
			inVariation := (rand.Float64() - 0.5) * 0.1 * fpsAmplitude
			// 15% variation for outFPS (more fluctuation)
			outVariation := (rand.Float64() - 0.5) * 0.3 * fpsAmplitude

			// Calculate independent FPS values
			inFPS := baseFPS + inVariation
			outFPS := baseFPS + outVariation

			// Update the global FPS variables
			storeInFPS(inFPS)
			storeOutFPS(outFPS)

			// Note: Metrics are automatically recorded via the observable gauge callback

			log.Printf("FPS in: %.2f, FPS out: %.2f (sine position: %.2f)",
				inFPS, outFPS, position)
		}
	}
}

func main() {
	log.Println("Starting FPS monitoring application with OTLP...")
	log.Printf("Version: %s", serviceVersion)
	log.Printf("Using OTLP endpoint: %s and hostname: %s", otlpEndpoint, hostname)

	// Initialize random with a default seed
	rand.New(rand.NewSource(time.Now().UnixNano()))

	// Create a context with signal handling
	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancel()

	// Initialize metrics
	shutdown, err := initMetrics(ctx)
	if err != nil {
		log.Fatalf("Failed to initialize metrics: %v", err)
	}
	defer func() {
		err := shutdown(context.Background())
		if err != nil {
			log.Fatalf("Failed to shutdown: %v", err)
		}
	}()

	// Start the FPS simulation
	simulateFPS(ctx)

	log.Println("Application stopped")
}
