package main

import (
	"context"
	"fmt"
	"log"
	"math"
	"math/rand"
	"net"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"sync/atomic"
	"time"
)

// buildVersion will be set during build via -ldflags
var buildVersion = "0.0.0" // Default version if not set during build

var (
	serviceName    = "fps-monitoring-app"
	serviceVersion = buildVersion // Use the build version
	hostname       = getEnv("HOSTNAME", "fps-host")
	socketPath     = getEnv("OTEL_SOCKET_PATH", "/metrics") // Default socket path, can be changed
	// FPS configuration
	minFPS     = 30.0             // Minimum FPS in the sine wave
	maxFPS     = 120.0            // Maximum FPS in the sine wave
	sinePeriod = 15 * time.Second // Complete sine wave cycle takes 15 seconds
)

// Global variable to track current FPS - use atomic operations for thread safety
var inFPSValue uint64 = 0  // FPS in value stored as bits
var outFPSValue uint64 = 0 // FPS out value stored as bits

// calculateInFPS returns the current in FPS value
func calculateInFPS() float64 {
	bits := atomic.LoadUint64(&inFPSValue)
	return math.Float64frombits(bits)
}

// calculateOutFPS returns the current out FPS value
func calculateOutFPS() float64 {
	bits := atomic.LoadUint64(&outFPSValue)
	return math.Float64frombits(bits)
}

// storeInFPS stores a float64 value atomically for FPS in
func storeInFPS(val float64) {
	bits := math.Float64bits(val)
	atomic.StoreUint64(&inFPSValue, bits)
}

// storeOutFPS stores a float64 value atomically for FPS out
func storeOutFPS(val float64) {
	bits := math.Float64bits(val)
	atomic.StoreUint64(&outFPSValue, bits)
}

// getEnv retrieves an environment variable or returns a default value if not set
func getEnv(key, defaultValue string) string {
	value, exists := os.LookupEnv(key)
	if !exists {
		return defaultValue
	}
	return value
}

func initMetrics(ctx context.Context) (func(context.Context) error, error) {
	// Ensure socket directory exists
	if err := os.MkdirAll(socketPath, 0755); err != nil {
		return nil, fmt.Errorf("failed to create socket directory: %w", err)
	}

	// Construct proper socket file path
	socketFile := filepath.Join(socketPath, hostname)

	// Remove socket file if it already exists
	if _, err := os.Stat(socketFile); err == nil {
		if err := os.Remove(socketFile); err != nil {
			return nil, fmt.Errorf("failed to remove existing socket file: %w", err)
		}
	}

	// Create metrics HTTP server for Unix socket
	metricsHandler := http.NewServeMux()
	metricsHandler.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) {
		// Return metrics in Prometheus format
		inFPS := calculateInFPS()
		outFPS := calculateOutFPS()
		w.Header().Set("Content-Type", "text/plain")
		fmt.Fprintf(w, "# HELP service_fps The frames per second generated by the application\n")
		fmt.Fprintf(w, "# TYPE service_fps gauge\n")
		fmt.Fprintf(w, "service_fps{state=\"in\"} %.2f\n", inFPS)
		fmt.Fprintf(w, "service_fps{state=\"out\"} %.2f\n", outFPS)
	})

	// Create listener for Unix domain socket
	lis, err := net.Listen("unix", socketFile)
	if err != nil {
		return nil, fmt.Errorf("failed to create UNIX socket listener: %w", err)
	}

	// Create and start metrics HTTP server on Unix socket
	metricsServer := &http.Server{Handler: metricsHandler}
	go func() {
		log.Printf("Starting metrics HTTP server on unix socket: %s", socketFile)
		if err := metricsServer.Serve(lis); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Failed to serve metrics HTTP server over unix socket: %v", err)
		}
	}()

	// Create hostname HTTP server for port 6080
	hostnameHandler := http.NewServeMux()
	hostnameHandler.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path != "/" {
			w.WriteHeader(http.StatusNotFound)
			return
		}
		w.Header().Set("Content-Type", "text/plain")
		fmt.Fprintf(w, "%s\n", hostname)
	})

	// Create and start hostname HTTP server on port 6080
	hostnameServer := &http.Server{
		Addr:    ":80",
		Handler: hostnameHandler,
	}
	go func() {
		log.Printf("Starting hostname HTTP server on port 80")
		if err := hostnameServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Failed to serve hostname HTTP server on port 80: %v", err)
		}
	}()

	// Return a function that will shut down both servers
	return func(ctx context.Context) error {
		// Shut down the metrics HTTP server
		if err := metricsServer.Shutdown(ctx); err != nil {
			log.Printf("Warning: Failed to shutdown metrics HTTP server: %v", err)
		}

		// Shut down the hostname HTTP server
		if err := hostnameServer.Shutdown(ctx); err != nil {
			log.Printf("Warning: Failed to shutdown hostname HTTP server: %v", err)
		}

		// Clean up the socket file
		if err := os.Remove(socketFile); err != nil {
			log.Printf("Warning: Failed to remove socket file: %v", err)
		}

		return nil
	}, nil
}

func simulateFPS(ctx context.Context) {
	// Set initial value
	initialFPS := (maxFPS + minFPS) / 2 // Start in the middle
	storeInFPS(initialFPS)
	storeOutFPS(initialFPS)

	// Calculate FPS range (amplitude of the sine wave)
	fpsAmplitude := (maxFPS - minFPS) / 2
	fpsMidpoint := (maxFPS + minFPS) / 2

	// Record the start time to calculate the sine wave position
	startTime := time.Now()

	// Main simulation loop
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			// Calculate elapsed time since start
			elapsed := time.Since(startTime)

			// Calculate the position in the sine wave (0 to 2Ï€)
			// A complete sine wave should take sinePeriod (2 minutes)
			position := 2 * math.Pi * (elapsed.Seconds() / sinePeriod.Seconds())

			// Calculate the sine value (-1 to 1)
			sineValue := math.Sin(position)

			// Convert sine value to FPS range
			baseFPS := fpsMidpoint + fpsAmplitude*sineValue

			// Add independent random variations
			// 5% variation for inFPS
			inVariation := (rand.Float64() - 0.5) * 0.1 * fpsAmplitude
			// 15% variation for outFPS (more fluctuation)
			outVariation := (rand.Float64() - 0.5) * 0.3 * fpsAmplitude

			// Calculate independent FPS values
			inFPS := baseFPS + inVariation
			outFPS := baseFPS + outVariation

			// Update the global FPS variables
			storeInFPS(inFPS)
			storeOutFPS(outFPS)

			log.Printf("FPS in: %.2f, FPS out: %.2f (sine position: %.2f)",
				inFPS, outFPS, position)
		}
	}
}

func main() {
	log.Println("Starting FPS monitoring application...")
	log.Printf("Version: %s", serviceVersion)
	log.Printf("Using socket directory: %s and hostname: %s", socketPath, hostname)

	// Initialize random with a default seed
	rand.New(rand.NewSource(time.Now().UnixNano()))

	// Create a context with signal handling
	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancel()

	// Initialize metrics
	shutdown, err := initMetrics(ctx)
	if err != nil {
		log.Fatalf("Failed to initialize metrics: %v", err)
	}
	defer func() {
		err := shutdown(context.Background())
		if err != nil {
			log.Fatalf("Failed to shutdown: %v", err)
		}
	}()

	// Start the FPS simulation
	simulateFPS(ctx)

	log.Println("Application stopped")
}
